#!/usr/bin/env bash
# soul-sync — Extract knowledge from agent runtimes into the portable soul repo
#
# Usage:
#   soul-sync                    # Sync from default sources
#   soul-sync --dry-run          # Show what would change without writing
#   soul-sync --commit           # Sync and auto-commit
#   soul-sync --source /path     # Sync from a specific knowledge directory

set -euo pipefail

# --- Configuration ---

SOUL_DIR="${SOUL_DIR:-$HOME/.soul}"
KNOWLEDGE_DIR="$SOUL_DIR/knowledge"
CORE_DIR="$SOUL_DIR/core"

# Agent knowledge directories to sync FROM (configure for your setup)
AGENT_SOURCES=(
  # Add your agent framework's knowledge directory here, e.g.:
  # "$HOME/.agent/knowledge/memories"
)

DRY_RUN=false
AUTO_COMMIT=false
CUSTOM_SOURCE=""

# --- Parse args ---

while [[ $# -gt 0 ]]; do
  case $1 in
    --dry-run) DRY_RUN=true; shift ;;
    --commit) AUTO_COMMIT=true; shift ;;
    --source) CUSTOM_SOURCE="$2"; shift 2 ;;
    *) echo "Unknown option: $1"; exit 1 ;;
  esac
done

if [[ -n "$CUSTOM_SOURCE" ]]; then
  AGENT_SOURCES=("$CUSTOM_SOURCE")
fi

# --- File mapping ---
# Returns "dest_path:strategy" for a given source filename

get_mapping() {
  case "$1" in
    lessons.md)      echo "knowledge/learning.md:merge-sections:## Lessons" ;;
    preferences.md)  echo "knowledge/learning.md:merge-sections:## Preferences" ;;
    decisions.md)    echo "knowledge/learning.md:merge-sections:## Decisions" ;;
    user-profile.md) echo "core/user.md:copy:" ;;
    bookmarks.md)    echo "knowledge/bookmarks.md:copy:" ;;
    continuity.md)   echo "knowledge/continuity.md:copy:" ;;
    sessions.md)     echo "knowledge/continuity.md:merge-sections:## Sessions" ;;
    followups.md)    echo "knowledge/followups.md:copy:" ;;
    *) echo "" ;;
  esac
}

# --- Functions ---

log() { echo "[soul-sync] $*"; }

ensure_dirs() {
  mkdir -p "$KNOWLEDGE_DIR" "$CORE_DIR"
}

sync_file_copy() {
  local src="$1" dest="$SOUL_DIR/$2"
  if [[ ! -f "$src" ]]; then return; fi

  if [[ -f "$dest" ]] && diff -q "$src" "$dest" >/dev/null 2>&1; then
    return  # identical, skip
  fi

  if $DRY_RUN; then log "[dry-run] Would copy $(basename "$src") → $2"; return; fi
  mkdir -p "$(dirname "$dest")"
  cp "$src" "$dest"
  log "Copied $(basename "$src") → $2"
}

sync_file_merge_sections() {
  local src="$1" dest="$SOUL_DIR/$2" section="$3"
  if [[ ! -f "$src" ]]; then return; fi
  if [[ -z "$section" ]]; then sync_file_copy "$src" "$2"; return; fi

  # Extract content from source (skip the first heading line, trim empty lines)
  local content
  content=$(sed '1{/^#/d;}' "$src" | sed '/^<!--/,/-->/d' | sed '/^$/d' | head -50)
  if [[ -z "$content" ]]; then return; fi

  # Ensure dest exists with basic structure
  if [[ ! -f "$dest" ]]; then
    if $DRY_RUN; then log "[dry-run] Would create $2"; return; fi
    mkdir -p "$(dirname "$dest")"
    cat > "$dest" << 'EOF'
# Learning

## Lessons

## Preferences

## Decisions
EOF
    log "Created $2"
  fi

  # Check if content already present (simple dedup on first non-empty line)
  local first_line
  first_line=$(echo "$content" | grep -v '^$' | head -1)
  if [[ -n "$first_line" ]] && grep -qF "$first_line" "$dest" 2>/dev/null; then
    return  # already synced
  fi

  if $DRY_RUN; then log "[dry-run] Would merge $(basename "$src") → $2 ($section)"; return; fi

  # Append content under the right section
  local tmpfile="$dest.tmp"
  awk -v section="$section" -v content="$content" '
    $0 == section { print; print ""; print content; next }
    { print }
  ' "$dest" > "$tmpfile" && mv "$tmpfile" "$dest"

  log "Merged $(basename "$src") → $2 ($section)"
}

sync_source() {
  local source_dir="$1"
  if [[ ! -d "$source_dir" ]]; then
    log "Skipping $source_dir (not found)"
    return
  fi

  log "Syncing from $source_dir"

  for src_file in "$source_dir"/*.md; do
    [[ -f "$src_file" ]] || continue
    local basename
    basename=$(basename "$src_file")
    local mapping
    mapping=$(get_mapping "$basename")

    if [[ -z "$mapping" ]]; then
      log "  No mapping for $basename, skipping"
      continue
    fi

    local dest_path strategy section
    dest_path=$(echo "$mapping" | cut -d: -f1)
    strategy=$(echo "$mapping" | cut -d: -f2)
    section=$(echo "$mapping" | cut -d: -f3-)

    case "$strategy" in
      copy) sync_file_copy "$src_file" "$dest_path" ;;
      merge-sections) sync_file_merge_sections "$src_file" "$dest_path" "$section" ;;
      *) log "  Unknown strategy '$strategy' for $basename" ;;
    esac
  done
}

do_commit() {
  if ! $AUTO_COMMIT; then return; fi
  if $DRY_RUN; then log "[dry-run] Would commit changes"; return; fi

  cd "$SOUL_DIR"
  if [[ ! -d .git ]]; then
    log "Soul dir is not a git repo, skipping commit"
    return
  fi

  if git diff --quiet && git diff --cached --quiet; then
    log "No changes to commit"
    return
  fi

  local timestamp
  timestamp=$(date +%Y-%m-%d)
  git add -A
  git commit -m "soul: sync knowledge $timestamp" --quiet
  log "Committed changes"
}

# --- Main ---

ensure_dirs

for source in "${AGENT_SOURCES[@]}"; do
  sync_source "$source"
done

do_commit

log "Done."
