#!/usr/bin/env bash
# soul-sync — Extract knowledge from agent runtimes into the portable soul repo
#
# Reads soul.config.yml from SOUL_DIR for all sources and domains.
# No hardcoded paths — everything is config-driven.
#
# Usage:
#   soul-sync                    # Sync from configured sources
#   soul-sync --dry-run          # Show what would change without writing
#   soul-sync --commit           # Sync and auto-commit

set -euo pipefail

SOUL_DIR="${SOUL_DIR:-$HOME/.soul}"
CONFIG_FILE="$SOUL_DIR/soul.config.yml"
KNOWLEDGE_DIR="$SOUL_DIR/knowledge"
CORE_DIR="$SOUL_DIR/core"

DRY_RUN=false
AUTO_COMMIT=false

while [[ $# -gt 0 ]]; do
  case $1 in
    --dry-run) DRY_RUN=true; shift ;;
    --commit) AUTO_COMMIT=true; shift ;;
    *) echo "Unknown option: $1"; exit 1 ;;
  esac
done

# --- Config parsing ---

parse_config() {
  if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "No config found at $CONFIG_FILE" >&2
    exit 1
  fi

  # Parse domains from soul.config.yml using python3
  python3 -c "
import yaml, json, os
with open('$CONFIG_FILE') as f:
    cfg = yaml.safe_load(f)
domains = cfg.get('knowledge', {}).get('domains', {})
# Expand ~ in paths
for name, d in domains.items():
    d['source'] = os.path.expanduser(d.get('source', ''))
    d['dest'] = d.get('dest', './knowledge/' + name)
    d['strategy'] = d.get('strategy', 'mirror' if name != 'general' else 'map')
print(json.dumps(domains))
"
}

# --- File mapping for 'map' strategy ---

get_mapping() {
  case "$1" in
    lessons.md)      echo "knowledge/learning.md:merge-sections:## Lessons" ;;
    preferences.md)  echo "knowledge/learning.md:merge-sections:## Preferences" ;;
    decisions.md)    echo "knowledge/learning.md:merge-sections:## Decisions" ;;
    user-profile.md) echo "core/user.md:copy:" ;;
    bookmarks.md)    echo "knowledge/bookmarks.md:copy:" ;;
    continuity.md)   echo "knowledge/continuity.md:copy:" ;;
    sessions.md)     echo "knowledge/continuity.md:merge-sections:## Sessions" ;;
    followups.md)    echo "knowledge/followups.md:copy:" ;;
    *) echo "" ;;
  esac
}

# --- Sync functions ---

log() { echo "[soul-sync] $*"; }

ensure_dirs() { mkdir -p "$KNOWLEDGE_DIR" "$CORE_DIR"; }

sync_file_copy() {
  local src="$1" dest="$SOUL_DIR/$2"
  [[ -f "$src" ]] || return
  if [[ -f "$dest" ]] && diff -q "$src" "$dest" >/dev/null 2>&1; then return; fi
  if $DRY_RUN; then log "[dry-run] Would copy $(basename "$src") → $2"; return; fi
  mkdir -p "$(dirname "$dest")"
  cp "$src" "$dest"
  log "Copied $(basename "$src") → $2"
}

sync_file_merge_sections() {
  local src="$1" dest="$SOUL_DIR/$2" section="$3"
  [[ -f "$src" ]] || return
  [[ -n "$section" ]] || { sync_file_copy "$src" "$2"; return; }

  local content
  content=$(sed '1{/^#/d;}' "$src" | sed '/^<!--/,/-->/d' | sed '/^$/d' | head -50)
  [[ -n "$content" ]] || return

  if [[ ! -f "$dest" ]]; then
    if $DRY_RUN; then log "[dry-run] Would create $2"; return; fi
    mkdir -p "$(dirname "$dest")"
    # Create with all known section headings
    cat > "$dest" << 'EOF'
# Learning

## Lessons

## Preferences

## Decisions
EOF
    log "Created $2"
  fi

  # Ensure target section heading exists
  if ! grep -qF "$section" "$dest" 2>/dev/null; then
    if $DRY_RUN; then log "[dry-run] Would add '$section' to $2"; return; fi
    echo -e "\n$section\n" >> "$dest"
  fi

  local first_line
  first_line=$(echo "$content" | grep -v '^$' | head -1)
  if [[ -n "$first_line" ]] && grep -qF "$first_line" "$dest" 2>/dev/null; then return; fi

  if $DRY_RUN; then log "[dry-run] Would merge $(basename "$src") → $2 ($section)"; return; fi

  local content_file
  content_file=$(mktemp)
  echo "" >> "$content_file"
  echo "$content" >> "$content_file"

  local tmpfile="$dest.tmp"
  local escaped_section
  escaped_section=$(echo "$section" | sed 's/[\/&]/\\&/g')
  sed "/$escaped_section/r $content_file" "$dest" > "$tmpfile" && mv "$tmpfile" "$dest"
  rm -f "$content_file"

  log "Merged $(basename "$src") → $2 ($section)"
}

sync_mapped() {
  local source_dir="$1"
  [[ -d "$source_dir" ]] || { log "Skipping $source_dir (not found)"; return; }
  log "Syncing (map) from $source_dir"

  for src_file in "$source_dir"/*.md; do
    [[ -f "$src_file" ]] || continue
    local basename mapping
    basename=$(basename "$src_file")
    mapping=$(get_mapping "$basename")
    [[ -n "$mapping" ]] || { log "  No mapping for $basename, skipping"; continue; }

    local dest_path strategy section
    dest_path=$(echo "$mapping" | cut -d: -f1)
    strategy=$(echo "$mapping" | cut -d: -f2)
    section=$(echo "$mapping" | cut -d: -f3-)

    case "$strategy" in
      copy) sync_file_copy "$src_file" "$dest_path" ;;
      merge-sections) sync_file_merge_sections "$src_file" "$dest_path" "$section" ;;
    esac
  done
}

sync_mirror() {
  local name="$1" source_dir="$2" dest_dir="$SOUL_DIR/$3"
  [[ -d "$source_dir" ]] || { log "Skipping domain '$name' — $source_dir not found"; return; }
  log "Syncing domain '$name' (mirror) from $source_dir"

  if $DRY_RUN; then
    local count
    count=$(find "$source_dir" -name "*.md" | wc -l | tr -d ' ')
    log "[dry-run] Would mirror $count files → $3/"
    return
  fi

  mkdir -p "$dest_dir"
  rsync -a --delete --include='*.md' --include='*/' --exclude='*' "$source_dir/" "$dest_dir/"
  log "Mirrored domain '$name' → $3/"
}

do_commit() {
  $AUTO_COMMIT || return
  if $DRY_RUN; then log "[dry-run] Would commit changes"; return; fi
  cd "$SOUL_DIR"
  [[ -d .git ]] || { log "Not a git repo, skipping commit"; return; }
  if git diff --quiet && git diff --cached --quiet; then log "No changes to commit"; return; fi
  git add -A
  git commit -m "soul: sync knowledge $(date +%Y-%m-%d)" --quiet
  log "Committed changes"
}

# --- Main ---

ensure_dirs

DOMAINS_JSON=$(parse_config)

# Write domain list to temp file to avoid subshell issues with piped while-read
DOMAIN_LIST=$(mktemp)
echo "$DOMAINS_JSON" | python3 -c "
import json, sys
domains = json.load(sys.stdin)
for name, d in domains.items():
    print(f\"{name}\t{d['source']}\t{d['dest']}\t{d['strategy']}\")
" > "$DOMAIN_LIST"

while IFS=$'\t' read -r name source dest strategy; do
  case "$strategy" in
    map) sync_mapped "$source" ;;
    mirror) sync_mirror "$name" "$source" "$dest" ;;
    *) log "Unknown strategy '$strategy' for domain '$name'" ;;
  esac
done < "$DOMAIN_LIST"

rm -f "$DOMAIN_LIST"

do_commit
log "Done."
